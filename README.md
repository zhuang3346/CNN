# CNN
EDA二轮考核

---

在 `self.fc1 = nn.Linear(64 * 8 * 8, 128)` 中，`64 * 8 * 8` 是经过卷积和池化操作后，特征图的展平尺寸。具体来说，它表示第二层卷积层输出的特征图的总元素数量。以下是对其来源的详细分析：

---

### **1. 模型结构**
在 `CNNModel` 类中，模型的结构如下：
```python
self.conv1 = nn.Conv2d(inputChannels, 32, kernel_size=3)  # 第一层卷积
self.pool = nn.MaxPool2d(2, 2)  # 最大池化层
self.conv2 = nn.Conv2d(32, 64, kernel_size=3)  # 第二层卷积
self.fc1 = nn.Linear(64 * 8 * 8, 128)  # 全连接层
```

---

### **2. 输入尺寸假设**
假设输入图像的尺寸为 `(height, width) = (38, 38)`，通道数为 `1`（单通道图像）。

---

### **3. 计算过程**
#### **(1) 第一层卷积**
- **卷积层**：`self.conv1 = nn.Conv2d(1, 32, kernel_size=3)`。
  - 输入形状：`(1, 38, 38)`。
  - 输出形状：`(32, 36, 36)`。
  - 计算公式：`output_size = (input_size - kernel_size + 1)`，即 `38 - 3 + 1 = 36`。
- **池化层**：`self.pool = nn.MaxPool2d(2, 2)`。
  - 输入形状：`(32, 36, 36)`。
  - 输出形状：`(32, 18, 18)`。
  - 计算公式：`output_size = input_size // 2`，即 `36 // 2 = 18`。

#### **(2) 第二层卷积**
- **卷积层**：`self.conv2 = nn.Conv2d(32, 64, kernel_size=3)`。
  - 输入形状：`(32, 18, 18)`。
  - 输出形状：`(64, 16, 16)`。
  - 计算公式：`output_size = (input_size - kernel_size + 1)`，即 `18 - 3 + 1 = 16`。
- **池化层**：`self.pool = nn.MaxPool2d(2, 2)`。
  - 输入形状：`(64, 16, 16)`。
  - 输出形状：`(64, 8, 8)`。
  - 计算公式：`output_size = input_size // 2`，即 `16 // 2 = 8`。

#### **(3) 展平**
- 第二层卷积和池化后的输出形状为 `(64, 8, 8)`。
- 展平后的尺寸为 `64 * 8 * 8 = 4096`。

---

### **4. 全连接层**
- **`self.fc1 = nn.Linear(64 * 8 * 8, 128)`**：
  - 输入尺寸：`64 * 8 * 8 = 4096`（展平后的特征图尺寸）。
  - 输出尺寸：`128`（全连接层的输出维度）。

---

### **5. 总结**
`64 * 8 * 8` 是经过以下步骤计算得到的：
1. **第一层卷积**：输入 `(1, 38, 38)` → 输出 `(32, 18, 18)`。
2. **第二层卷积**：输入 `(32, 18, 18)` → 输出 `(64, 8, 8)`。
3. **展平**：将 `(64, 8, 8)` 展平为 4096 个元素。

因此，`64 * 8 * 8` 表示第二层卷积和池化后特征图的总元素数量，作为全连接层的输入尺寸。
