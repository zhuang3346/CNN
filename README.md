# CNN模型定义

---

### **1. 模型结构**
在 `CNNModel` 类中，模型的结构如下：
```python
self.conv1 = nn.Conv2d(inputChannels, 32, kernel_size=3)  # 第一层卷积
self.pool = nn.MaxPool2d(2, 2)  # 最大池化层
self.conv2 = nn.Conv2d(32, 64, kernel_size=3)  # 第二层卷积
self.fc1 = nn.Linear(64 * 8 * 8, 128)  # 全连接层
```

---

### **2. 输入尺寸假设**
假设输入图像的尺寸为 `(height, width) = (38, 38)`，通道数为 `1`（单通道图像）。

---

### **3. 计算过程**
#### **(1) 第一层卷积**
- **卷积层**：`self.conv1 = nn.Conv2d(1, 32, kernel_size=3)`。
  - 输入形状：`(1, 38, 38)`。
  - 输出形状：`(32, 36, 36)`。
  - 计算公式：`output_size = (input_size - kernel_size + 1)`，即 `38 - 3 + 1 = 36`。
- **池化层**：`self.pool = nn.MaxPool2d(2, 2)`。
  - 输入形状：`(32, 36, 36)`。
  - 输出形状：`(32, 18, 18)`。
  - 计算公式：`output_size = input_size // 2`，即 `36 // 2 = 18`。

#### **(2) 第二层卷积**
- **卷积层**：`self.conv2 = nn.Conv2d(32, 64, kernel_size=3)`。
  - 输入形状：`(32, 18, 18)`。
  - 输出形状：`(64, 16, 16)`。
  - 计算公式：`output_size = (input_size - kernel_size + 1)`，即 `18 - 3 + 1 = 16`。
- **池化层**：`self.pool = nn.MaxPool2d(2, 2)`。
  - 输入形状：`(64, 16, 16)`。
  - 输出形状：`(64, 8, 8)`。
  - 计算公式：`output_size = input_size // 2`，即 `16 // 2 = 8`。

#### **(3) 展平**
- 第二层卷积和池化后的输出形状为 `(64, 8, 8)`。
- 展平后的尺寸为 `64 * 8 * 8 = 4096`。

---

### **4. 全连接层**
- **`self.fc1 = nn.Linear(64 * 8 * 8, 128)`**：
  - 输入尺寸：`64 * 8 * 8 = 4096`（展平后的特征图尺寸）。每个批次一个向量
  - 输出尺寸：`128`（全连接层的输出`维度（长度）`）。
  - 形象说明：假设：`batch_size=16`（批次大小为16，即16个节点）。则在`self.fc1`中，输入`x`：形状为`(16，4096)`，表示16个样本，每个样本有4096维特征，输出`x`：形状为`(16，128)`，表示16个样本，每个样本有128维特征。

---

### **5. 输出层**
- **`self.fc2 = nn.Linear(128, numClasses)`**：
  - 输入尺寸：`128`（从全连接层输出的`维度（长度）`）。
  - 输出尺寸：`numClasses`（节点标签类别）。
  - 形象说明：假设：`batch_size=16`（批次大小为16，即16个节点），`numClasses=6`。则在`self.fc2`中，输入`x`：形状为`(16，128)`，表示16个样本，每个样本有128维特征，输出`x`：形状为`(16，6)`，表示16个样本，每个样本有6个类别的预测分数。

---

### **5. 总结**
`64 * 8 * 8` 是经过以下步骤计算得到的：
1. **第一层卷积**：输入 `(1, 38, 38)` → 输出 `(32, 18, 18)`。
2. **第二层卷积**：输入 `(32, 18, 18)` → 输出 `(64, 8, 8)`。
3. **展平**：将 `(64, 8, 8)` 展平为 4096 个元素。

因此，`64 * 8 * 8` 表示第二层卷积和池化后特征图的总元素数量，作为全连接层的输入尺寸。
